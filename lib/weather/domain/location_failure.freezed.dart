// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'location_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$LocationFailureTearOff {
  const _$LocationFailureTearOff();

  _LocationDisabled locationDisabled([String? msg]) {
    return _LocationDisabled(
      msg,
    );
  }

  _Denied denied([String? msg]) {
    return _Denied(
      msg,
    );
  }

  _DeniedForever deniedForever([String? msg]) {
    return _DeniedForever(
      msg,
    );
  }
}

/// @nodoc
const $LocationFailure = _$LocationFailureTearOff();

/// @nodoc
mixin _$LocationFailure {
  String? get msg => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? msg) locationDisabled,
    required TResult Function(String? msg) denied,
    required TResult Function(String? msg) deniedForever,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? msg)? locationDisabled,
    TResult Function(String? msg)? denied,
    TResult Function(String? msg)? deniedForever,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? msg)? locationDisabled,
    TResult Function(String? msg)? denied,
    TResult Function(String? msg)? deniedForever,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LocationDisabled value) locationDisabled,
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LocationDisabled value)? locationDisabled,
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LocationDisabled value)? locationDisabled,
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LocationFailureCopyWith<LocationFailure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocationFailureCopyWith<$Res> {
  factory $LocationFailureCopyWith(
          LocationFailure value, $Res Function(LocationFailure) then) =
      _$LocationFailureCopyWithImpl<$Res>;
  $Res call({String? msg});
}

/// @nodoc
class _$LocationFailureCopyWithImpl<$Res>
    implements $LocationFailureCopyWith<$Res> {
  _$LocationFailureCopyWithImpl(this._value, this._then);

  final LocationFailure _value;
  // ignore: unused_field
  final $Res Function(LocationFailure) _then;

  @override
  $Res call({
    Object? msg = freezed,
  }) {
    return _then(_value.copyWith(
      msg: msg == freezed
          ? _value.msg
          : msg // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$LocationDisabledCopyWith<$Res>
    implements $LocationFailureCopyWith<$Res> {
  factory _$LocationDisabledCopyWith(
          _LocationDisabled value, $Res Function(_LocationDisabled) then) =
      __$LocationDisabledCopyWithImpl<$Res>;
  @override
  $Res call({String? msg});
}

/// @nodoc
class __$LocationDisabledCopyWithImpl<$Res>
    extends _$LocationFailureCopyWithImpl<$Res>
    implements _$LocationDisabledCopyWith<$Res> {
  __$LocationDisabledCopyWithImpl(
      _LocationDisabled _value, $Res Function(_LocationDisabled) _then)
      : super(_value, (v) => _then(v as _LocationDisabled));

  @override
  _LocationDisabled get _value => super._value as _LocationDisabled;

  @override
  $Res call({
    Object? msg = freezed,
  }) {
    return _then(_LocationDisabled(
      msg == freezed
          ? _value.msg
          : msg // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_LocationDisabled extends _LocationDisabled {
  const _$_LocationDisabled([this.msg]) : super._();

  @override
  final String? msg;

  @override
  String toString() {
    return 'LocationFailure.locationDisabled(msg: $msg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LocationDisabled &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(msg);

  @JsonKey(ignore: true)
  @override
  _$LocationDisabledCopyWith<_LocationDisabled> get copyWith =>
      __$LocationDisabledCopyWithImpl<_LocationDisabled>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? msg) locationDisabled,
    required TResult Function(String? msg) denied,
    required TResult Function(String? msg) deniedForever,
  }) {
    return locationDisabled(msg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? msg)? locationDisabled,
    TResult Function(String? msg)? denied,
    TResult Function(String? msg)? deniedForever,
  }) {
    return locationDisabled?.call(msg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? msg)? locationDisabled,
    TResult Function(String? msg)? denied,
    TResult Function(String? msg)? deniedForever,
    required TResult orElse(),
  }) {
    if (locationDisabled != null) {
      return locationDisabled(msg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LocationDisabled value) locationDisabled,
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
  }) {
    return locationDisabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LocationDisabled value)? locationDisabled,
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
  }) {
    return locationDisabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LocationDisabled value)? locationDisabled,
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    required TResult orElse(),
  }) {
    if (locationDisabled != null) {
      return locationDisabled(this);
    }
    return orElse();
  }
}

abstract class _LocationDisabled extends LocationFailure {
  const factory _LocationDisabled([String? msg]) = _$_LocationDisabled;
  const _LocationDisabled._() : super._();

  @override
  String? get msg => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$LocationDisabledCopyWith<_LocationDisabled> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$DeniedCopyWith<$Res>
    implements $LocationFailureCopyWith<$Res> {
  factory _$DeniedCopyWith(_Denied value, $Res Function(_Denied) then) =
      __$DeniedCopyWithImpl<$Res>;
  @override
  $Res call({String? msg});
}

/// @nodoc
class __$DeniedCopyWithImpl<$Res> extends _$LocationFailureCopyWithImpl<$Res>
    implements _$DeniedCopyWith<$Res> {
  __$DeniedCopyWithImpl(_Denied _value, $Res Function(_Denied) _then)
      : super(_value, (v) => _then(v as _Denied));

  @override
  _Denied get _value => super._value as _Denied;

  @override
  $Res call({
    Object? msg = freezed,
  }) {
    return _then(_Denied(
      msg == freezed
          ? _value.msg
          : msg // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_Denied extends _Denied {
  const _$_Denied([this.msg]) : super._();

  @override
  final String? msg;

  @override
  String toString() {
    return 'LocationFailure.denied(msg: $msg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Denied &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(msg);

  @JsonKey(ignore: true)
  @override
  _$DeniedCopyWith<_Denied> get copyWith =>
      __$DeniedCopyWithImpl<_Denied>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? msg) locationDisabled,
    required TResult Function(String? msg) denied,
    required TResult Function(String? msg) deniedForever,
  }) {
    return denied(msg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? msg)? locationDisabled,
    TResult Function(String? msg)? denied,
    TResult Function(String? msg)? deniedForever,
  }) {
    return denied?.call(msg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? msg)? locationDisabled,
    TResult Function(String? msg)? denied,
    TResult Function(String? msg)? deniedForever,
    required TResult orElse(),
  }) {
    if (denied != null) {
      return denied(msg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LocationDisabled value) locationDisabled,
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
  }) {
    return denied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LocationDisabled value)? locationDisabled,
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
  }) {
    return denied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LocationDisabled value)? locationDisabled,
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    required TResult orElse(),
  }) {
    if (denied != null) {
      return denied(this);
    }
    return orElse();
  }
}

abstract class _Denied extends LocationFailure {
  const factory _Denied([String? msg]) = _$_Denied;
  const _Denied._() : super._();

  @override
  String? get msg => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$DeniedCopyWith<_Denied> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$DeniedForeverCopyWith<$Res>
    implements $LocationFailureCopyWith<$Res> {
  factory _$DeniedForeverCopyWith(
          _DeniedForever value, $Res Function(_DeniedForever) then) =
      __$DeniedForeverCopyWithImpl<$Res>;
  @override
  $Res call({String? msg});
}

/// @nodoc
class __$DeniedForeverCopyWithImpl<$Res>
    extends _$LocationFailureCopyWithImpl<$Res>
    implements _$DeniedForeverCopyWith<$Res> {
  __$DeniedForeverCopyWithImpl(
      _DeniedForever _value, $Res Function(_DeniedForever) _then)
      : super(_value, (v) => _then(v as _DeniedForever));

  @override
  _DeniedForever get _value => super._value as _DeniedForever;

  @override
  $Res call({
    Object? msg = freezed,
  }) {
    return _then(_DeniedForever(
      msg == freezed
          ? _value.msg
          : msg // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_DeniedForever extends _DeniedForever {
  const _$_DeniedForever([this.msg]) : super._();

  @override
  final String? msg;

  @override
  String toString() {
    return 'LocationFailure.deniedForever(msg: $msg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DeniedForever &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(msg);

  @JsonKey(ignore: true)
  @override
  _$DeniedForeverCopyWith<_DeniedForever> get copyWith =>
      __$DeniedForeverCopyWithImpl<_DeniedForever>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? msg) locationDisabled,
    required TResult Function(String? msg) denied,
    required TResult Function(String? msg) deniedForever,
  }) {
    return deniedForever(msg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? msg)? locationDisabled,
    TResult Function(String? msg)? denied,
    TResult Function(String? msg)? deniedForever,
  }) {
    return deniedForever?.call(msg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? msg)? locationDisabled,
    TResult Function(String? msg)? denied,
    TResult Function(String? msg)? deniedForever,
    required TResult orElse(),
  }) {
    if (deniedForever != null) {
      return deniedForever(msg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LocationDisabled value) locationDisabled,
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
  }) {
    return deniedForever(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LocationDisabled value)? locationDisabled,
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
  }) {
    return deniedForever?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LocationDisabled value)? locationDisabled,
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    required TResult orElse(),
  }) {
    if (deniedForever != null) {
      return deniedForever(this);
    }
    return orElse();
  }
}

abstract class _DeniedForever extends LocationFailure {
  const factory _DeniedForever([String? msg]) = _$_DeniedForever;
  const _DeniedForever._() : super._();

  @override
  String? get msg => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$DeniedForeverCopyWith<_DeniedForever> get copyWith =>
      throw _privateConstructorUsedError;
}
